class ParallelExploitation:
    pass

def IsMergeable(trees):
    # assume: if IsMergeable(a, b) == True and IsMergeable(a, c) == True then IsMergeable(b, c) == True
    for i in range(len(trees)-1):
        if trees[0].IsMergeable(trees[i+1]) == False:
            return False
    return True

# assumptions:
#   each subtree is either a statement operating on tensors, a nested loop iterating over the access domain of a tensor array or a block of statements
#     a. for the tensor case, take fusion of gates' computations in LSTM cell as an example, carefully process the element wise computation node (map)
#     b. for the tensor array case, require the access (iteration) domain and code structure of inner statements to be identical / isomorphic
def MergeSet(trees):
    # variable renaming (a map from old var name to new var name stored in ctx?), this function is also needed in MergeLoop
    if trees[0].type() == "kLoop":
        # TODO
        return None
    elif trees[0].type() == "kBlock":
        # TODO
        return None
    elif trees[0].type() == "kStatement":
        # TODO
        return None
    else:
        # do nothing
        return trees

def TryMergeSet(tree):
    if IsMergeable(tree.children()):
        return MergeSet(tree.children())
    else:
        return tree

# assumption: after feautrier scheduler, dependences are carried by the outer loops and inner loops can be parallelizable
def TryMergeLoop(tree):
    # 1: locate the first parallelizable loop
    # 2: check whether the statements can be optimized by batching input tensors
    # 3: properly insert gather and scatter (may need to leverage poly IR), mention the name rebinding
    return tree

class BatchTensor(ParallelExploitation):
    @staticmethod
    def run(tree):
        def dfs(tree):
            if tree.annotation() == "kBoundary":
                return tree
            # process the subtrees first
            node = tree
            if node.type() == "kLoop":
                node = node.down_to_deepest_loop()
            for i, u in enumerate(node.children()):
                node.set_children(i, dfs(u))
            if tree.type() == "kSet":
                return TryMergeSet(tree)
            elif tree.type() == "kLoop":
                return TryMergeLoop(tree)
            return tree
        return dfs(tree)

class Distribute(ParallelExploitation):
    def run(self, tree):
        pass