class ParallelExploitation:
    pass

def IsMergeable(trees):
    # if IsMergeable(a, b) == True and IsMergeable(a, c) == True then IsMergeable(b, c) == True
    for i in range(len(trees)-1):
        if trees[0].IsMergeable(trees[i+1]) == False:
            return False
    return True

# assumptions:
# 1. each subtree is either a statement operating on tensors or a nested loop iterating over the access domain of a tensor array
# 2. for the tensor case, take fusion of gates' computations in LSTM cell as an example, carefully process the element wise computation node (map)
# 3. for the tensor array case, require the access (iteration) domain and code structure of inner statements to be identical / isomorphic
def MergeSet(trees):
    # variable renaming (a map from old var name to new var name stored in ctx?)
    # shape (meta info) propagating
    if trees[0].type() == "kLoop":
        return None
    elif trees[0].type() == "kBlock":
        # TODO: do we need this?
        return None
    elif trees[0].type() == "kStatement":

        return None
    else:
        return None

def TryMergeSet(tree):
    if IsMergeable(tree.children()):
        return MergeSet(tree.children())
    else:
        return tree

# need clear definition of nested loop
# input code pattern:
#  L_0(i_0)
#    L_1(i_1)
#      ...
#        L_n(i_n)
#          [S_0, S_1, ..., S_m]
# constraints:
#  1. each iterator is an induced variable, initial value is 0, increment is 1, upper bound is a symbolic constant or a certain bound of a Tensor Array
#  2. if-else is not considered currently
#  3. all statements are in the deepest loop and follow the SSA requirements: left hand side (write in) is a accessed tensor in array, right hand side is an element in tensor array or context (scope)
def TryMergeLoop(tree):
    return tree

class BatchTensor(ParallelExploitation):
    def run(self, tree):
        def dfs(tree):
            # when tree is a loop node, children here refer to the statements in the deepest nested loop
            for i, u in enumerate(tree.children()):
                # heuristic strategy: process the subtrees first
                tree.set_children(i, dfs(u))
            if tree.type() == "kSet":
                return TryMergeSet(tree)
            elif tree.type() == "kLoop":
                return TryMergeLoop(tree)
            else:
                return tree
        return dfs(tree)

class Distribute(ParallelExploitation):
    def run(self, tree):
        pass