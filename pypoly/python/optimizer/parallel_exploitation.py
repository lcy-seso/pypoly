class ParallelExploitation:
    pass

def IsMergeable(trees):
    # if IsMergeable(a, b) == True and IsMergeable(a, c) == True then IsMergeable(b, c) == True
    for i in range(len(trees)-1):
        if trees[0].IsMergeable(trees[i+1]) == False:
            return False
    return True

# assumptions:
# 1. each subtree is either a statement operating on tensors or a nested loop iterating over the access domain of a tensor array
# 2. for the tensor case, take fusion of gates' computations in LSTM cell as an example, carefully process the element wise computation node (map)
# 3. for the tensor array case, require the access (iteration) domain and code structure of inner statements to be identical / isomorphic
def MergeSet(trees):
    # variable renaming (a map from old var name to new var name stored in ctx?)
    # shape (meta info) propagating
    if trees[0].type() == "kLoop":
        return None
    elif trees[0].type() == "kBlock":
        # TODO: do we need this?
        return None
    elif trees[0].type() == "kStatement":
        return None
    else:
        return None

def TryMergeSet(tree):
    if IsMergeable(tree.children()):
        return MergeSet(tree.children())
    else:
        return tree

# assumption: after feautrier scheduler, dependences are carried by the outer loops and inner loops may be parallelizable
def TryMergeLoop(tree):
    # 1: locate the first parallelizable loop
    # 2: check whether the statements can be optimized by batching input tensors
    # 3: properly insert gather and scatter (may need to leverage poly IR), mention the name rebinding
    return tree

class BatchTensor(ParallelExploitation):
    @staticmethod
    def run(self, tree):
        def dfs(tree):
            if tree.annotation() == "kBoundary":
                return tree
            # process the subtrees first
            node = tree
            if node.type() == "kLoop":
                node = node.down_to_deepest_loop()
            for i, u in enumerate(node.children()):
                node.set_children(i, dfs(u))
            if tree.type() == "kSet":
                return TryMergeSet(tree)
            elif tree.type() == "kLoop":
                return TryMergeLoop(tree)
            return tree
        return dfs(tree)

class Distribute(ParallelExploitation):
    def run(self, tree):
        pass