# frontend
# here repeat elements are stored as reference
layer_x_inits = x_init_state.repeat(len(x_encs)).repeat(depth)
layer_y_inits = y_init_state.repeat(len(y_encs)).repeat(depth)

extended_x_encs = x_encs.map((x_enc) { return x_enc.repeat(len(y_encs))} )
extended_y_encs = y_encs.repeat(len(x_encs))

# lambda functions in scan share same signature (a, b) -> a, where 'a' is the type of the initial variable, 'b' is the type of elements in the list that is scanned
# the return type is 'a'. As a result, the type of the final result is List[a]

# scan along depth
# the type of 'init' is {TensorArray(src_len, tgt_len), TensorArray(src_len, tgt_len)}
# the type of returned element is {TensorArray(depth, src_len, tgt_len), TensorArray(depth, src_len, tgt_len)}
# the first dim of layer_x_inits, layer_y_inits and weights is depth
out = scanl(
    (prev_layer_out, inits) {
        x_inits, y_inits, weight = inits
        # scan along source sequence
        # the type of 'init' is {TensorArray(tgt_len), TensorArray(tgt_len)}
        # the type of returned element is {TensorArray(src_len, tgt_len), TensorArray(src_len, tgt_len)}
        # the first dim of x_inits and prev_layer_out is src_len
        return scanl(
            (vertical_states, horizontal_elements) {
                x_init, prev_vertical = horizontal_elements
                # scan along target sequence
                # the type of 'init" is {Tensor(hidden_dim), Tensor(hidden_dim)}
                # the type of returned element is {TensorArray(tgt_len), TensorArray(tgt_len)}
                # the first dim of vertical_states and prev_vertical is tgt_len
                return scanl(
                    [](prev_x_states, tupled_states) {
                        x_state, _ = prev_x_states
                        _, y_state = tupled_states[0]
                        x_t, y_t = tupled_states[1]
                        h_prev = tensor.concat((x_state, y_state), dim=1)
                        return {cell(h_prev, x_t, weight), cell(h_prev, y_t, weight)}
                    },
                    {vertical_states, prev_vertical}
                    init={x_init, none}
                )
            },
            {x_inits, prev_layer_out},
            init={none, y_inits}
        )
    },
    {layer_x_inits, layer_y_inits, weights}
    init={extended_x_encs, extended_y_encs}
)

# normalized IR
function foo(prev_x_states, tupled_states, weight) {
    x_state, _ = prev_x_states
    _, y_state = tupled_states[0]
    x_t, y_t = tupled_states[1]
    h_prev = tensor.concat((x_state, y_state), dim=1)
    return {cell(h_prev, x_t, weight), cell(h_prev, y_t, weight)}
}

for (c0, len(layer_x_inits))
    if c0 == 0
        for (c1, len(x_encs))
            if c1 == 0
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {{none, y_init_state}, {x_encs[c1], y_encs[c2]}}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {out[c0][c1][c2-1], {x_encs[c1], y_encs[c2]}}, weights[c0])
            else
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {{none, y_init_state}, {x_encs[c1], y_encs[c2]}}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {out[c0][c1][c2-1], {x_encs[c1], y_encs[c2]}}, weights[c0])
    else
        for (c1, len(x_encs))
            if c1 == 0
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {{none, y_init_state}, out[c0-1][c1][c2]}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {out[c0][c1][c2-1], out[c0-1][c1][c2]}, weights[c0])
            else
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {{none, y_init_state}, out[c0-1][c1][c2]}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {out[c0][c1][c2-1], out[c0-1][c1][c2]}, weights[c0])