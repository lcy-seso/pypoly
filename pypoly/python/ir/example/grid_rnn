# frontend
# here repeat elements may be stored as references at runtime
layer_x_inits = x_init_state.repeat(len(x_encs)).repeat(depth)
layer_y_inits = y_init_state.repeat(len(y_encs)).repeat(depth)

extended_x_encs = x_encs.map((x_enc) { return x_enc.repeat(len(y_encs))} )
extended_y_encs = y_encs.repeat(len(x_encs))

# Generally, we are applying the cell function to structured tensor arrays. Users only need to prepare (transform) data following certain rules
# and the function will automatically launched along dimensions one by one.

# lambda functions in scan share same signature (a, b) -> a, where 'a' is the type of the initial variable, 'b' is the type of elements in the list that is scanned
# the return type is 'a'. As a result, the type of the final result is List[a]

# scan along depth
# the type of 'init' is {TensorArray(src_len, tgt_len), TensorArray(src_len, tgt_len)}
# the type of returned element is {TensorArray(depth, src_len, tgt_len), TensorArray(depth, src_len, tgt_len)}
# the first dim of layer_x_inits, layer_y_inits and weights is depth
out = scanl(
    (prev_layer_out, inits) {
        x_inits, y_inits, weight = inits
        # scan along source sequence
        # the type of 'init' is {TensorArray(tgt_len), TensorArray(tgt_len)}
        # the type of returned element is {TensorArray(src_len, tgt_len), TensorArray(src_len, tgt_len)}
        # the first dim of x_inits and prev_layer_out is src_len
        return scanl(
            [weight](vertical_states, horizontal_elements) {
                x_init, prev_vertical = horizontal_elements
                # scan along target sequence
                # the type of 'init" is {Tensor(hidden_dim), Tensor(hidden_dim)}
                # the type of returned element is {TensorArray(tgt_len), TensorArray(tgt_len)}
                # the first dim of vertical_states and prev_vertical is tgt_len
                return scanl(
                    (prev_x_states, tupled_states) {
                        x_state, _ = prev_x_states
                        _, y_state = tupled_states[0]
                        x_t, y_t = tupled_states[1]
                        h_prev = tensor.concat((x_state, y_state), dim=1)
                        return {cell(h_prev, x_t, weight), cell(h_prev, y_t, weight)}
                    },
                    {vertical_states, prev_vertical}
                    init={x_init, none}
                )
            },
            {x_inits, prev_layer_out},
            init={none, y_inits}
        )
    },
    {layer_x_inits, layer_y_inits, weights}
    init={extended_x_encs, extended_y_encs}
)

# a possible high level interface
out = scan_by_dim(
    # dimension binding / referring:
    # prev_x_states -> [0, 1]
    # prev_y_states -> [0, 2]
    # prev_layer_states -> [1, 2]
    # weight -> [0]
    (prev_x_states, prev_y_states, prev_layer_states, context={weight}) {
        x_state, _ = prev_x_states
        _, y_state = prev_y_states
        x_t, y_t = prev_layer_states
        h_prev = tensor.concat((x_state, y_state), dim=1)
        return {cell(h_prev, x_t, weight), cell(h_prev, y_t, weight)}
    },
    context=[(weights, [0])],
    init=[(layer_x_inits, [0, 1]), (layer_y_inits, [0, 2]), (extended_x_encs, [1, 2]), (extended_y_encs, [1, 2])]
)

# normalized IR
function foo(prev_x_states, tupled_states, weight) {
    x_state, _ = prev_x_states
    _, y_state = tupled_states[0]
    x_t, y_t = tupled_states[1]
    h_prev = tensor.concat((x_state, y_state), dim=1)
    return {cell(h_prev, x_t, weight), cell(h_prev, y_t, weight)}
}

for (c0, len(layer_x_inits))
    if c0 == 0
        for (c1, len(x_encs))
            if c1 == 0
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {{none, y_init_state}, {x_encs[c1], y_encs[c2]}}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {out[c0][c1][c2-1], {x_encs[c1], y_encs[c2]}}, weights[c0])
            else
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {{none, y_init_state}, {x_encs[c1], y_encs[c2]}}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {out[c0][c1][c2-1], {x_encs[c1], y_encs[c2]}}, weights[c0])
    else
        for (c1, len(x_encs))
            if c1 == 0
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {{none, y_init_state}, out[c0-1][c1][c2]}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, {x_init_state, none}, {out[c0][c1][c2-1], out[c0-1][c1][c2]}, weights[c0])
            else
                for (c2, len(y_encs))
                    if c2 == 0
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {{none, y_init_state}, out[c0-1][c1][c2]}, weights[c0])
                    else
                        out[c0][c1][c2] = apply(foo, out[c0][c1-1][c2], {out[c0][c1][c2-1], out[c0-1][c1][c2]}, weights[c0])