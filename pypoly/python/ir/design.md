Op Type

- add, sub, mul, div
- eq, ne, le, ge, lt, gt
- and, xor, or, not
- neg

Expr Access Type

- may read
- may write
- must write

Expr: args: List[Expr]

- access
  - access type
- call
  - func-name: string
- op
  - op type

Tree

- expr
  - expr: Expr
- block
  - children: List[Tree]
- decl-init
  - var: Expr
  - init: Expr
- if-else
  - cond: Expr
  - then-body: Tree
  - else-body: Tree
- for
  - iv: Expr
  - init: Expr
  - cond: Expr
  - inc: Expr
  - body: Tree

Notes

1. no assignment in op type, assignment in a statement is stored as a 'decl-init' tree node
2. arithmetic ops are only used in conditional expressions (on scalar values)
3. computations on tensor in a statement are represented by function calls
4. like PET, a variable is represented by an access expression
5. different from PET, no 'int' or 'double' types, all variables are either Tensor or Tensor Array type and stored as references to certain memory regions
6. nested function calls will be split into multiple statements following SSA rules
7. tensors and tensor arrays are generated by *functions* or *nested loops*, for tensors, static dimensions are inferred directly from the static loop bound, for tensor arrays, dynamic (parametric) dimensions are inherited or inferred from the dynamic loop bound