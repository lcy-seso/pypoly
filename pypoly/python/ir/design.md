Variable Type

- Tensor (scalar represented as tensor?)
  - data type
  - shape
  - layout
- Tensor Array (inherit from *List*)
  - length
  - item list of tensors or tensor arrays
  - tensor info
  - depth
  - layout
  - label the static and dynamic dimensions?
  - dimension info propagation?
- Object Reference
  - initial object
- Tuple (inherit from *List*)
  - length
  - item list of object references

Op Type (system interfaces)

- basic arithmetic
  - unary
    - neg
  - binary
    - add, sub, mul, div
    - eq, ne, le, ge, lt, gt
    - and, xor, or, not
    - max, min
- computation: *a* and *b* below are all tensors, iterable object refers to data structures inherited from *List*
  - map
    - iterable object: List[*a*]
    - lambda function: *a* -> *b*
    - return type: List[*b*]
  - scan (fold)
    - initial variable: *a*
    - iterable object: List[*b*]
    - lambda function: (*a*, *b*) -> *a*
    - return type: List[*a*]
- data movement
  - gather
    - iterable variable: List[*a*]
    - index: List[tuple<*int*>]
    - return type: *b*
  - scatter
    - iterable variable: List[*a*]
    - input tensor: *b*
    - index: List[tuple<*int*>]
    - no return type, in place assignment / modification to the iterable variable

Expr Access Type

- may read
- may write
- must write

Expr

- type ? (check the array part in PET)
- args: List[Expr]

Expr Type

- access (variable name is included in this category)
  - access type
- call
  - func-name (optional for lambda function): string
- op
  - op type
- int (initial value, increment)

Tree

- computation
  - inputs: List[Expr]
  - output: Expr
  - block: Tree
- expr (differences against decl-init), call functions with no return statement
  - expr: Expr
- block
  - children: List[Tree]
- decl-init
  - var: Expr
  - init: Expr
- if-else
  - cond: Expr
  - then-body: Tree
  - else-body: Tree
- for
  - iv: Expr
  - init: Expr
  - cond: Expr
  - inc: Expr
  - body: Tree

Important utility interfaces of Tree

- Shape propagation: static and dynamic
- Function signature generation
- Meta info propagation: tell whether inputs of a function can be batched
- Fuse / merge code (tree, computation)

Notes

1. no assignment in op type, assignment in a statement is stored as a 'decl-init' tree node
2. arithmetic ops are only used in conditional expressions (on scalar values)
3. computations on tensor in a statement are represented by function calls
4. like PET, a variable is represented by an access expression
5. different from PET, no 'int' or 'double' types, all variables are either Tensor or Tensor Array type and stored as references to certain memory regions
6. nested function calls will be split into multiple statements following SSA rules
7. tensors and tensor arrays are generated by *functions* or *nested loops*, for tensors, static dimensions are inferred directly from the static loop bound, for tensor arrays, dynamic (parametric) dimensions are inherited or inferred from the dynamic loop bound